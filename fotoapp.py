# -*- coding: utf-8 -*-
"""Proyecto_2_Jacqueline_Urban.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-cVBH3IwnQ9DNit4oPHSzPEAkVTlpzq5

# Suponer que estamos creando una App para editar y compartir fotos en diferentes redes sociales:

1. Escribir una función que reciba como parámetros dos strings, uno contendrá la ruta
 para acceder a una imagen (Drive o URL), y el otro una palabra clave, que podrá ser
 “Youtube, Instagram, Twitter o Facebook”. La función debe leer/abrir la foto y
 redimensionar la imagen al tamaño adecuado especificado como parámetro para
 cada una de las palabras clave (busque las dimensiones recomendadas de cada
 aplicación).
 Nota: Tenga en cuenta la escala, no queremos que la foto se distorsione.
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
# Para visualizar en Colab
from google.colab.patches import cv2_imshow # cv.imshow
from PIL import Image, ImageFilter
import matplotlib.pyplot as plt
import os

# Para leer imagenes de Google Drive
#from google.colab import drive
#drive.mount('/content/drive')

# Path de la carpeta donde tenemos las imágenes
#folder = "/content/drive/My Drive/UPSO/Python Avanzada 2024-2/Clases/data/imgs/" #@param {type:"string"}
#ruta = '/content/drive/MyDrive/UPSO/TÉCNICO A UNIVERSITARIO A EN TECNOLOGÍAS DE PROGRAMACIÓN/2° Cuatrimestre/Python avanzado/Proyecto_2/img/'

#import cv2 # pip install

# Para visualizar en Colab
#from google.colab.patches import cv2_imshow # cv.imshow

# Leer imagen
#img = cv2.imread(ruta + 'gato.jpg', cv2.IMREAD_COLOR)
#cv2_imshow(img)

#img.shape

#funciona pero deforma la foto


#primerStrRuta : contendrá la ruta para acceder a una imagen (Drive o URL)
#segundoStrClave : contendrá una palabra clave, que podrá ser “Youtube, Instagram, Twitter o Facebook”.

  # # tamaños = {
  #     "YouTube": (1280, 720),
  #     "Instagram": (1080, 1080),
  #     "Twitter": (1200, 675),
  #     "Facebook": (1200, 630)
  # }


def LeerAbrirRedimensionar( strRuta , strPalabaraClave ):

    img_leida = cv2.imread(strRuta)

    if strPalabaraClave == 'YouTube':
        img_redimensionada = cv2.resize(img_leida, (1280, 720))

    elif strPalabaraClave == 'Instagram':
        img_redimensionada = cv2.resize(img_leida, (1080, 1080))

    elif strPalabaraClave == 'Twitter':
        img_redimensionada = cv2.resize(img_leida, (1200, 675))

    elif strPalabaraClave == 'Facebook':
        img_redimensionada = cv2.resize(img_leida, (1200, 630))

    else:
        raise ValueError("Palabra clave no válida. Use 'YouTube', 'Instagram', 'Twitter' o 'Facebook'.")


    cv2_imshow(img_redimensionada)
    cv2.imwrite('imagen_redim_'+ strPalabaraClave +'.png', img_redimensionada)

    return img_redimensionada

#prueba
#nueva_imagen = LeerAbrirRedimensionar(ruta + 'gato.jpg', 'YouTube')

""" 2. Crea una función que ajuste el contraste de la foto utilizando su histograma. Probala
 con una foto oscura y con otra con exceso de luz. Muestra la foto original y la
 ecualizada en una misma figura y guárdela en ambos casos (Adjuntar las figuras a la
 solución del proyecto).

"""

def AjustarContrasteImg(img):
    # Verificar si la imagen es válida
    if img is None:
        raise ValueError("La imagen no es válida.")

    # Convertir a escala de grises si la imagen está en color
    if len(img.shape) == 3:  # Si la imagen tiene 3 canales, está en color
        img_gris = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    else:
        img_gris = img  # Si ya está en escala de grises

    # Aplicar ecualización de histograma
    equ = cv2.equalizeHist(img_gris)

    # Calcular el histograma
    hist, bins = np.histogram(equ.flatten(), 256, [0, 256])

    # Calcular la función de distribución acumulativa (CDF) normalizada
    cdf = hist.cumsum()
    cdf_normalized = cdf * float(hist.max()) / cdf.max()

    # Mostrar las imágenes
    print("Imagen Original:")
    cv2_imshow(img_gris)

    print("Imagen Ecualizada:")
    cv2_imshow(equ)

    # Retornar la imagen original y la ecualizada
    return

#AjustarContrasteImg(nueva_imagen)
#

#nueva_imagen = LeerAbrirRedimensionar(ruta + 'dog.jpg', 'YouTube')

def AjustarContrasteImg(img):
    # Verificar si la imagen es válida
    if img is None:
        raise ValueError("La imagen no es válida.")

    # Guardar la imagen original
    img_original = img.copy()

    # Convertir a espacio de color YUV
    img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)

    # Aplicar ecualización de histograma solo al canal de luminancia (Y)
    img_yuv[:, :, 0] = cv2.equalizeHist(img_yuv[:, :, 0])

    # Convertir de nuevo a BGR
    img_ecualizada = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR)

    # Guardar las imágenes
    cv2.imwrite('imagen_original.png', img_original)
    cv2.imwrite('imagen_ecualizada.png', img_ecualizada)

    # Mostrar las imágenes
    plt.figure(figsize=(12, 6))

    # Mostrar la imagen original
    plt.subplot(1, 2, 1)
    plt.title("Imagen Original")
    plt.imshow(cv2.cvtColor(img_original, cv2.COLOR_BGR2RGB))
    plt.axis('off')  # Ocultar ejes

    # Mostrar la imagen ecualizada
    plt.subplot(1, 2, 2)
    plt.title("Imagen Ecualizada")
    plt.imshow(cv2.cvtColor(img_ecualizada, cv2.COLOR_BGR2RGB))
    plt.axis('off')  # Ocultar ejes

    plt.show()

#AjustarContrasteImg(nueva_imagen)

""" 3. Programar una función que aplique los 9 filtros de Pillow de la siguiente tabla. La
 función debe incluir en sus parámetros el nombre del filtro que el usuario quiere usar.
 Muestra y guarda la foto resultante (adjuntar). Además, muestra la foto original y las
 9 resultantes si se aplicaran todos los filtros en una misma figura y guárdela en
 ambos casos (Adjuntar). Nota: Ponerle como título a cada foto el nombre del filtro, e
 indique al usuario cuál fue el filtro que eligió (por ejemplo con el color del título
 diferente).

 ORIGINAL     | BLUR

 CONTOUR      | DETAIL

 EDGE ENHANCE | EDGE ENHANCE MORE

 EMBOSS       | FIND EDGES

 SHARPEN      | SMOOTH




"""

# filters = {
#     'ORIGINAL': None,
#     'BLUR': ImageFilter.BLUR,
#     'CONTOUR': ImageFilter.CONTOUR,
#     'DETAIL': ImageFilter.DETAIL,
#     'EDGE ENHANCE': ImageFilter.EDGE_ENHANCE,
#     'EDGE ENHANCE MORE': ImageFilter.EDGE_ENHANCE_MORE,
#     'EMBOSS': ImageFilter.EMBOSS,
#     'FIND EDGES': ImageFilter.FIND_EDGES,
#     'SHARPEN': ImageFilter.SHARPEN,
#     'SMOOTH': ImageFilter.SMOOTH
# }esto se va a mostrar en el menu, para que el usuario pueda seleccionar el filtro

def filtrosMostrarGuardar(ruta_imagen, filtro_seleccionado):
    # Verificar si la imagen existe en la ruta
    if not os.path.exists(ruta_imagen):
        raise FileNotFoundError(f"La imagen en la ruta {ruta_imagen} no se encontró.")

    # Cargar la imagen
    img_original = Image.open(ruta_imagen)

    # Definición de los filtros de Pillow
    filtros = {
        'ORIGINAL': None,
        'BLUR': ImageFilter.BLUR,
        'CONTOUR': ImageFilter.CONTOUR,
        'DETAIL': ImageFilter.DETAIL,
        'EDGE ENHANCE': ImageFilter.EDGE_ENHANCE,
        'EDGE ENHANCE MORE': ImageFilter.EDGE_ENHANCE_MORE,
        'EMBOSS': ImageFilter.EMBOSS,
        'FIND EDGES': ImageFilter.FIND_EDGES,
        'SHARPEN': ImageFilter.SHARPEN,
        'SMOOTH': ImageFilter.SMOOTH
    }

    # Aplicar el filtro seleccionado
    if filtro_seleccionado not in filtros:
        raise ValueError("El filtro seleccionado no es válido.")

    img_filtrada = img_original if filtro_seleccionado == 'ORIGINAL' else img_original.filter(filtros[filtro_seleccionado])

    # Guardar la imagen filtrada
    img_filtrada.save(f"{filtro_seleccionado}_imagen.png")

    # Mostrar la imagen original y la filtrada seleccionada
    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1)
    plt.title("Imagen Original")
    plt.imshow(img_original)
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.title(f"Imagen con filtro: {filtro_seleccionado}")
    plt.imshow(img_filtrada)
    plt.axis('off')

    plt.show()

    # Crear y guardar una figura con la imagen original y todas las versiones filtradas
    fig, axes = plt.subplots(2, 5, figsize=(15, 6))
    for ax, (nombre_filtro, filtro) in zip(axes.flatten(), filtros.items()):
        # Aplicar cada filtro a la imagen original
        img_procesada = img_original if filtro is None else img_original.filter(filtro)
        ax.imshow(img_procesada)
        ax.set_title(nombre_filtro, fontsize=10)
        ax.axis('off')

    # Guardar la figura con todas las imágenes
    plt.tight_layout()
    plt.savefig("todas_las_imagenes_con_filtros.png")
    plt.show()

#filtrosMostrarGuardar(ruta + 'gato.jpg', 'EMBOSS')

"""4. Se llevó a cabo un análisis de usuarios que demostró que el 35% de los posibles
 futuros usuarios son pintores que compartirían fotos de sus trabajos allí, por lo cual
 te pedimos que diseñes una funcionalidad en Python para asistirlos, el objetivo es
 que cuando el algoritmo identifica con IA que la foto leída es de una persona
 (suponga que hay otra función que ya ha hecho este paso previo con una variable
 persona=True), ayude a los usuarios a dibujar el boceto de la persona de la foto.
 Pruebe su función con una foto de un personaje de su elección.

  El resultado puede ser una imagen binarizada como la del ejemplo (con fondo
 blanco o negro), o una imagen que realce mucho los bordes… Usá tu creatividad y
 justificá el resultado de tu función demostrando que sería la mejor herramienta para
 los usuarios pintores/dibujantes comparando diferentes resultados.

"""

def crearBoceto(ruta_imagen, persona=True):
    """
    Función que toma una imagen y crea un boceto de la persona en la foto.

    Parámetros:
    - ruta_imagen: str, ruta a la imagen que se desea procesar.
    - persona: bool, indica si la imagen contiene una persona (predeterminado=True).

    Devuelve:
    - Muestra el boceto de la imagen.
    """
    if not persona:
        print("No se ha detectado una persona en la imagen. Función no aplicada.")
        return

    # Leer la imagen en escala de grises
    imagen = cv2.imread(ruta_imagen, cv2.IMREAD_GRAYSCALE)
    if imagen is None:
        raise FileNotFoundError("La imagen no se encontró en la ruta especificada.")

    # Aplicar un desenfoque para reducir el ruido
    imagen_desfocada = cv2.GaussianBlur(imagen, (5, 5), 0)

    # Realzar bordes usando el algoritmo Canny
    bordes = cv2.Canny(imagen_desfocada, 50, 150)

    # Invertir los colores para un fondo blanco y líneas negras
    imgBoceto = cv2.bitwise_not(bordes)

    # Mostrar la imagen original y el boceto
    plt.figure(figsize=(10, 5))

    # Mostrar la imagen original
    plt.subplot(1, 2, 1)
    plt.title("Imagen Original")
    plt.imshow(cv2.cvtColor(cv2.imread(ruta_imagen), cv2.COLOR_BGR2RGB))
    plt.axis('off')

    # Mostrar el boceto
    plt.subplot(1, 2, 2)
    plt.title("Boceto")
    plt.imshow(imgBoceto, cmap="gray")
    plt.axis('off')


    # Guardar el boceto
    cv2.imwrite("boceto_persona.png", imgBoceto)
    plt.show()

    # Guardar el boceto
    cv2.imwrite(f'{ruta_imagen} .jpg', imgBoceto)
    plt.show()

#crearBoceto(ruta + 'dog.jpg')